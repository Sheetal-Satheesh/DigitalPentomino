<html>

<head>
<title>Simple Pentomino</title>
<script>

/*

Class PIECE - Model/Data for the pieces (Backend)

*/

class Piece {
	
 constructor(type, game){
 	
 	//convenience 
	 this.Game=game;
	//  console.log(game)	 	
 	
 	if (!type) type='';
 	
	 type=type.toUpperCase();
	//  console.log(type)
 	this.name=type;
 	
 	//every piece has its shape as a bitmap and other
 	//properties describing its presentation
 	switch (type){
 		
		case 'F':this.trayPosition=0;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,0,1,1,0],
                 [0,1,1,0,0],
                 [0,0,1,0,0],
                 [0,0,0,0,0]
                ]; break;

 		case 'I':this.trayPosition=1;
 				 this.bitMap=[
                 [0,0,1,0,0],
                 [0,0,1,0,0],
                 [0,0,1,0,0],
                 [0,0,1,0,0],
                 [0,0,1,0,0]
                ]; break;

 		case 'L':
 				 this.trayPosition=2;
 				 this.bitMap=[
                 [0,0,1,0,0],
                 [0,0,1,0,0],
                 [0,0,1,0,0],
                 [0,0,1,1,0],
                 [0,0,0,0,0]
                ]; break;N
 		case 'N':
 				 this.trayPosition=3;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,0,1,0,0],
                 [0,0,1,0,0],
                 [0,1,1,0,0],
                 [0,1,0,0,0]
                ]; break;

 		case 'P':
 				 this.trayPosition=4;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,0,1,1,0],
                 [0,0,1,1,0],
                 [0,0,1,0,0],
                 [0,0,0,0,0]
                ]; break;

 		case 'T':
 				 this.trayPosition=5;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,1,1,1,0],
                 [0,0,1,0,0],
                 [0,0,1,0,0],
                 [0,0,0,0,0]
                ]; break;

 		case 'U':this.trayPosition=6;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,1,0,1,0],
                 [0,1,1,1,0],
                 [0,0,0,0,0],
                 [0,0,0,0,0]
                ]; break;
                
 		case 'V':this.trayPosition=7;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,0,1,0,0],
                 [0,0,1,0,0],
                 [0,0,1,1,1],
                 [0,0,0,0,0]
                ]; break;
                
 		case 'W':this.trayPosition=8;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,1,0,0,0],
                 [0,1,1,0,0],
                 [0,0,1,1,0],
                 [0,0,0,0,0]
                ]; break;

 		case 'X':this.trayPosition=9;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,0,1,0,0],
                 [0,1,1,1,0],
                 [0,0,1,0,0],
                 [0,0,0,0,0]
                ]; break;

 		case 'Y':this.trayPosition=10;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,0,1,0,0],
                 [0,0,1,1,0],
                 [0,0,1,0,0],
                 [0,0,1,0,0]
                ]; break;

 		case 'Z':this.trayPosition=11;
 				 this.bitMap=[
                 [0,0,0,0,0],
                 [0,1,1,0,0],
                 [0,0,1,0,0],
                 [0,0,1,1,0],
                 [0,0,0,0,0]
                ]; break;

         default:this.trayPosition=-1;
 				 this.name='ERROR';
                 this.bitMap=[  //here we should never get
                 [1,1,1,1,1],
                 [1,1,1,1,1],
                 [1,1,1,1,1],
                 [1,1,1,1,1],
                 [1,1,1,1,1]
                ];	
 	}
 	
 	//positioning information.
 	//Upon creation, pieces are in the tray
 	
 	this.inTray=true;
 	this.position=false;
 	
  }
  
  //Rotation and flipping functions: Create a new bitmap by parsing the old one
  

  rotateRight(){
  	var output=[[],[],[],[],[]];
  	
  	for (let row=0;row<5;row++){
  		for (let col=0;col<5;col++){
  		
  		   let newRow=col;
  		   let newCol=4-row;
  		   
  		   output[newRow][newCol]=this.bitMap[row][col];
  		
  		}
  	}
  	
  	this.bitMap=output;
  	
  	this.Game.updateVisu(this);
  	
  	return this;
  }
  
  rotateLeft(){
  	var output=[[],[],[],[],[]];
  	
  	for (let row=0;row<5;row++){
  		for (let col=0;col<5;col++){
  		
  		   let newRow=4-col;
  		   let newCol=row;
  		   
  		   output[newRow][newCol]=this.bitMap[row][col];
  		
  		}
  	}
  	
  	this.bitMap=output;
  	
	  this.Game.updateVisu(this);
	//   console.log(this)
  	
  	return this;
  }

  
  flipH(){
  	var output=[[],[],[],[],[]];
  	
  	for (let row=0;row<5;row++){
  		for (let col=0;col<5;col++){
  		
  		   let newRow=row;
  		   let newCol=4-col;
  		   
  		   output[newRow][newCol]=this.bitMap[row][col];
  		
  		}
  	}
  	
  	this.bitMap=output;
  	
  	this.Game.updateVisu(this);
  	
  	return this;
  }
  
  flipV(){
  	var output=[[],[],[],[],[]];
  	
  	for (let row=0;row<5;row++){
  		for (let col=0;col<5;col++){
  		
  		   let newRow=4-row;
  		   let newCol=col;
  		   
  		   output[newRow][newCol]=this.bitMap[row][col];
  		
  		}
  	}
  	
  	this.bitMap=output;
  	
  	this.Game.updateVisu(this); //inform the frontend about changes
  	
  	return this;	
  	
  }
  
  //place a pice onto a position within the game grid
  place(x,y){
  	
  	let position=[x,y];
  	
  	this.inTray=false;
  	this.position=position;
  	
  	//TODO: Pentomino logic belongs here
  	//Has it been placed on the board?
  	//Is there a collision?
  	
  	this.Game.updateVisu(this); //inform the frontend about changes
  	
  	return this;
  }
  
  //remove pieces from the game grid and put it back into the tray
  toTray(){
  	this.inTray=true;
  	this.position=false;
  	
  	this.Game.updateVisu(this); //inform the frontend about changes
  	
  	return this;
  	
  }

  //TODO: This is in the wrong place. Selection handling is UI or visualisation stuff!
  select(){
  	
  	this.Game.setSelection(this);
  	
  }

  toString(){
  	let out=this.name;
  	
  	if (this.inTray) {
  		out+=' in tray';
  	} else {
  		out+=' on '+this.position;
  	}
  	
  	return out;
  }
  

}

/*

Class GAME - Model/Data for the Pentomino game (Backend)

*/


class Game{
	
	constructor(pd){
		
		this.pd=pd;
		this.visual=pd.visual;
		
	    //TODO: These configuration aspects should of course not be hardcoded,
	    //but be part of config files.
		
	    //dimensions of the game
		
		this.width=25;
		this.height=12;
		
		this.selected=false;
		
		// standard configuration
		
		let config={};
		config.dimensions=[10,6];
		config.blocked=[]; // Blocked positions in board. No implementation yet
		config.pieces=['F','I','L','N','P','T','U','V','W','X','Y','Z'];
		
		//load the initial board;		
		this.loadBoard(config);
	}
	
	//load a board with the configuration provided
	loadBoard(config){
		if (!config) return;
		
		this.pieces={};
		this.pieceArray=[];
		
		//create the datastructures for the actual pieces
		for(let i in config.pieces){
			this.pieces[config.pieces[i]]=new Piece(config.pieces[i],this);			
			this.pieceArray[i]=this.pieces[config.pieces[i]];
		}
		
		//position the board on the game field
		this.boardDimensions=config.dimensions;
		this.boardX=Math.floor((this.width-config.dimensions[0])/2);
		this.boardY=Math.floor((this.height-config.dimensions[1])/2);
		// console.log("Inside loadboard::",this)
		return this;
		
	}
	
	//get the piece object by the given nem
	get(piece){ // provide acces to a piece
		// console.log("piece in get",piece)
		piece=piece.toUpperCase();
		return this.pieces[piece];
	
	}
	//setOnload function accepts a input parameter 'loadPiece' which contains saved game state and its configuration
	setOnload(loadPiece){	
		var arr=this.pieces		
		var json={};		
		for(var i in arr){
			arr[i]['bitMap']=loadPiece[i]['bitMap']
			arr[i]['inTray']=loadPiece[i]['inTray']
			arr[i]['position']=loadPiece[i]['position']			
		}
		this.pd.visual.renderPieces();	
	}
	
	
	//called in case of any change to piece data. Relays the changes to visual
	updateVisu(piece){
		
		if (!this.pd.visual) return;
		
		this.pd.visual.renderPieces(); // this is a very poor solution as it renders all pieces again.
		
		//TODO: relay the piece to the visualisation and handle it there in a more
		//sensible manner
	}
	
	//TODO: This is in the wrong place: Selection is UI or visualisation matter
	setSelection(piece){
		// console.log("selected Piece ",piece)
		this.selected=piece;
		// this.pd.visual.save(piece);
		// this.pd.visual.load();
		this.pd.visual.showManipulations(piece);
	}
	
	//TODO: This is in the wrong place: Selection is UI or visualisation matter
	deleteSelection(){
		
		if (!this.selected) return;
		
		this.selected=false;
	
		this.pd.visual.hideManipulations();
	}
	
}

/*

Class UI - The User Interface (Frontend)

This class should create all the visual structures on the screen which are not the
game itself.

TODO: Big parts are hardcoded into HTML and CSS at the moment and/or are created
by setting the innerHTML property. This has to be reconsidered and cleaned up.

*/

class UI{
	
	constructor(pd){
		
		this.pd=pd;
		
		//TODO: Creation of the basic structure should happen in here
		
	}
	
	//TODO: Selection handling belongs here instead of the game class
	
	//manipulation functions applied to the currently selected object
	
	rotateRight(){
		var piece=this.pd.game.selected;
		if (!piece) return;
		piece.rotateRight();
	}
	
	rotateLeft(){
		var piece=this.pd.game.selected;
		if (!piece) return;
		piece.rotateLeft();
	}
	
	flipV(){
		var piece=this.pd.game.selected;
		if (!piece) return;
		piece.flipV();
	}
	
	flipH(){
		var piece=this.pd.game.selected;		
		if (!piece) return;
		piece.flipH();
	}
	
	save(){
		var arr=this.pd.game.pieces //Storing circular structure (pieces which contains all 12 piece information in a variable 'arr') 		
		//logic to eliminate circular structure and load it as a plain json in localstorage with variable name 'SAVEGAME'
		var json={};		
		for(var i in arr){
			var jsonObj={};
			var ob=this.pd.game.get(i);	 
			for(var j in ob){
				if(j!='Game'){
					jsonObj[j]=ob[j]
				}
			json[i]=jsonObj;			 
			}
		}
		// console.log("after elimination of circular structure::",JSON.stringify(json))	 
		localStorage.setItem('SAVEGAME',JSON.stringify(json));
	}
		//Accepts input from local storage variable 'SAVEGAME' and passes it to setONload function present in Game class
	load(){
		var obj=JSON.parse(localStorage.getItem('SAVEGAME'));

		this.pd.game.setOnload(obj);		
	}

	//logic to eliminate circular structure and load it as a plain json variable which will be used later to store it in a file named 'PentominoGameSave'
	export(){
		var arr=this.pd.game.pieces		
		var json={};
		for(var i in arr){
			var jsonObj={};
			var ob=this.pd.game.get(i);		 
			for(var j in ob){
				if(j!='Game'){
					jsonObj[j]=ob[j]
				}
			json[i]=jsonObj;			 
			}
		}

		var test = JSON.stringify(json);
		console.log(test);
		//Returns a newly created Blob object which contains all of the data passed from variable 'test'. Mainly used to store files. 
		var blob = new Blob([test], {type: "application/json;charset=utf-8"}); 
		var url = URL.createObjectURL(blob);		
		//Anchor tag where href is pointing to blob(file path)'
		var elem = document.createElement("a");
		// console.log("the content of elements is::",elem)		
		var filename="PentominoGameSave"
		elem.href = url;
		elem.download = filename;
		document.body.appendChild(elem);
		elem.click();
		document.body.removeChild(elem);
	}

	//Getting the contents from localstorage variable named 'IMPORT_FILE' and passing to setOnload function present in Game class
	import(){		
		var file_content = localStorage.getItem('IMPORT_FILE');		
		this.pd.game.setOnload(JSON.parse(file_content));
		console.log("importing::",file_content);
	}
	
		//Reset game to initial state and configuration
	reset(){
		let config={};
		config.dimensions=[10,6];
		config.blocked=[]; // Blocked positions in board. No implementation yet
		config.pieces=['F','I','L','N','P','T','U','V','W','X','Y','Z'];
		
		this.pd.game.loadBoard(config);
		this.pd.visual.renderPieces();
	}
}
	/*

Class Visual - The visual aspects of the game (Frontend)

*/

class Visual{
	
	constructor(pd){
		
		//convenience
		
		this.PD=pd;
		this.game=pd.game;
		
		//Create all visual structures of the game
		
		this.renderBoard();
		this.renderPieces();
		
		//Create interaction listeners
		
		this.initalizeListeners();
	}
	
	//Create the field on which pieces can be put
	renderBoard(){
		
		//TODO: Check whether in the innerHTML approach is good here!
		
		var fieldHTML=document.getElementById('field');
		
		
		var out='';
		
		var width=90/this.game.width;
		
		//The field consists of divs. Each div saves in its id field its resepective
		//coorinates
		
		for (var row=0;row<this.game.height;row++){
			for (var col=0;col<this.game.width;col++){
				
				var isBoard=true;
				
				//indicate where on the field the board is
				
				//TODO: Implement blocked elements
				
				if (col<this.game.boardX) isBoard=false;
				if (col>=this.game.boardX+this.game.boardDimensions[0]) isBoard=false;
				if (row<this.game.boardY) isBoard=false;
				if (row>=this.game.boardY+this.game.boardDimensions[1]) isBoard=false;
				
				//TODO: This is ugly!
				
				out+='<div class="gamearea '+((isBoard)?'boardarea':'')+'" id="field_'+col+','+row+'" title="'+col+','+row+'" style="width:'+width+'vw;height:'+width+'vw;"></div>';   //'+col+','+row+'
			}
		}
		
		fieldHTML.innerHTML=out;
	}
	
	//Create the visual representations of the pieces
	renderPieces(){
		
		//TODO: Check whether in the innerHTML approach is good here!
		//
		//Thoughts: It is okay if renderPieces is only called at the start
		//of a game and pice updates are handeled differently.
		//
		//If this function should also handle updates, it should rather check
		//whether elements already exist and update their respective properties
		//instead of creating the pieces again and again.
		
		var pieceArea=document.getElementById('piecearea');
		
		let out='';

		var width=90/this.game.width;
		
		//create the pieces
		
		for (var p in this.game.pieces){
			var piece=this.game.pieces[p];		
			
			//this are the bouding boxes into which the piece itself is "painted"
			//setting to display:none avoids the appearing for a split second before positioning
			
			out+='<div class="piece" id="piece_'+piece.name+'" style="width:'+(5*width)+'vw;height:'+(5*width)+'vw;display:none">';
			
			//this "paints" the bitmap of the pice into the bounding box
			for(var i in piece.bitMap){
						var row=piece.bitMap[i];
						for (var j in row){
							var set=piece.bitMap[i][j];
							if(piece.name=="F")//For different color for different piece
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:blue':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="I")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:red':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="L")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:yellow':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="N")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:green':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="P")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:purple':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="T")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:coral':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="U")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:lime':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="V")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:chocolate':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="W")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:maroon':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="X")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:peru':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="Y")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:brown':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else if(piece.name=="Z")
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:indigo':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
							else
							{
								out+='<div style="display:block;float:left;width:'+width+'vw;height:'+width+'vw;'+((set)?'background:black':'')+'" class="'+((set)?'bmPoint':'bmAround')+'"></div>';
							}
						}
						
					}
			out+='</div>';
			
			//positioning the pieces has to happen after the elements are created
			//TODO: this is a disadvantage of chosing the innerHTML approach. 
			
			setTimeout(function(that,piece){
				that.positionPiece(piece);
			},0,this,piece);
			
			
		}
		
		pieceArea.innerHTML=out;
		
	}
	
	positionPiece(piece){
		
	   var width=90/this.game.width;
	   var htmlElement=document.getElementById('piece_'+piece.name);
	   
	   if (piece.inTray){
	   	   var trayPosition=piece.trayPosition;	   
	   	   
	   	   var widthVW=10+(piece.trayPosition)*7; //7 is trayHeight
	   	   
	   	   var magnification=6/(5*width);
	   	   
	   	   htmlElement.style.left=widthVW+'vw';
	   	   htmlElement.style.transform='scale('+magnification+')';
	   	   htmlElement.style.transformOrigin='0 5%'; 	   

	   } else {
	   	   
	   	   var left=10+width*(piece.position[0]-2);
	   	   var top=7+width*(piece.position[1]-2);
	   	   
	   	   htmlElement.style.left=left+'vw';
	   	   htmlElement.style.top=top+'vw';
	   	   htmlElement.style.transform='scale(1)';
	   	   htmlElement.style.transformOrigin='50% 50%'; 	
	   	
	   }
	   
	   //making the element visible (see remark in renderPieces)
	   htmlElement.style.display='block'; 
		
	}
	
	//show or hide the manipulation buttons
	//TODO: Dirty! The UI needs to sensibly handle those things!!
	
	showManipulations(piece){
		// console.log("Show Manipulation::",piece)		
		document.getElementById('operations').style.display='block';
	}
	
	hideManipulations(){
		document.getElementById('operations').style.display='none';
	}
// 	save(piece) {
// 		console.log("insave::",piece)
// 	  	localStorage.setItem('piece',piece);
// 	}

// load() {
//   let piece2 = localStorage.getItem('piece');
//   document.getElementById('operations').style.display='block';
//   console.log("getting state::",piece2)
// }
	
	
	//initialize input listeners.
	initalizeListeners(){
		
		var that=this;
		
		//pointer events generalize mouse and touch events
		//the events are registered on the document object
		//in order to avoid problems of losing objects when moving too fast
		//(which can happen in mouse interaction).
		//
		//Ad differnt things have to happen in relation to different
		//kinds of objects and in different states of the application
		//this basically becomes a big state automaton.
				
		document.onpointerdown=function(event){//clicking or moving begins
				
			//check, whether action started on a gamepiece
			
			//get all elements on the given positions and go through them.
			//This has to be done instead of getting the element which has been
			//clicked onto from the event, as transparent parts of
			//bounding box pieces can overlap other pieces, so the element
			//which is technically clicked onto may not be the one visually
			//clicked onto. But we need that one.
			
			var elements=document.elementsFromPoint(event.clientX, event.clientY);
				
			for (var i in elements){
				var check=elements[i].className;
				if (check!=='bmPoint') continue;
				
				//as soon as we have a bmPoint(an element of a piece), 
				//we determine the bounding box and the piece object itself
				//and save those into a global variable "currentlyMoving"
				//which we access during movement and at the end of movement.
				
				var piece=elements[i*1+1].id.split('_')[1];
			
				if (!piece) return;
				
				var container=elements[i*1+1];       //For some strange reason, i is a String, using *1 to convert it
				var piece=that.PD.game.get(piece);
			
				window.currentlyMoving=[container,piece];
			}
			
			return;
			
		}
		
		document.onpointermove=function(event){
			
			//move an object in case a drag operation stared on a piece (see above)
			
			if (window.currentlyMoving){
				
				var x=event.clientX;
				var y=event.clientY;
				
				var container=window.currentlyMoving[0];
				
				//resize object to full size while moving and attach their center to the
				//pointer
				
				var width=90/that.PD.game.width;
				
				container.style.left='calc('+x+'px - '+(width*2.5)+'vw)';
				container.style.top='calc('+y+'px - '+(width*2.5)+'vw)';
				container.style.transform='scale(1)';
	   	   		container.style.transformOrigin='50% 50%';
	
			}
		}

		document.onpointerup=function(event){
			
			//this is called when mouse key is released or fingers are removed from the screen
			
			if (window.currentlyMoving){
				
				//in case an object was in the process of being moved, this changes the movement.
				//which means it is determined, where it was moved to and then the backend is informed
				//about that movement (which in turn  repositions the element so it snaps to the grid)
				
				var data=window.currentlyMoving;
				window.currentlyMoving=false;
				
				//determine the target
				
				var elements=document.elementsFromPoint(event.clientX, event.clientY);
				
				for (var i in elements){
					var element=elements[i];
					var id=element.id;
					
					//determine the position the piece ended on
					
					if (id=='tray') return data[1].toTray();
					
					if (id.split('_')[0]=='field'){
						
						var coords=(id.split('_')[1].split(','));

						data[1].place(coords[0],coords[1]);
						
						// make this the selected element which activates manipulation GUI
						
						data[1].select();
						
					//	<!-- var obj = JSON.parse(localStorage.getItem('SAVEGAME')); -->
						
						
					//	<!-- console.log("before",obj[data[1].name]); -->
					//	<!-- obj[data[1].name]['bitMap'] = data[1].bitMap; -->
					//	<!-- obj[data[1].name]['inTray'] = data[1].inTray; -->
					//	<!-- obj[data[1].name]['position'] = data[1].position; -->
						
						
					//	<!-- localStorage.setItem('SAVEGAME',JSON.stringify(obj)); -->
					//	<!-- console.log("after",localStorage.getItem('SAVEGAME')); -->
						
						that.PD.ui.save();
						
						return;
						
					}
				}
			
				
			} else {
				
				// in case nothing was moving, this becomes an unselect operation
				
				var elements=document.elementsFromPoint(event.clientX, event.clientY);
				
				for (var i in elements){
					var element=elements[i];
					if (element.id=='functions') return; //do not unselect if operations have been applied to the functions panel
				}
				
				that.game.deleteSelection();
				
			}
		}		
		
	}
	
}

/*

Class PD - For PentominoDigital. Create the necessary structures and connect them with each other

*/
class PD{

	constructor(){
		this.ui=new UI(this);
		this.game=new Game(this);
		this.visual=new Visual(this);
		//Refresh button on the browser which loads the saved game state with configuration
		this.ui.load();
	}

}

function initialize(){
	//Import the file which contains the last saved state
	//Step1: Accepting the input file which contains the information of last saved state
	//Step2: Loading the contents of the file in a local storage variable i.e 'IMPORT_FILE'
	document.querySelector("#file-input").addEventListener('change', function() {
	var file = document.querySelector("#file-input").files[0];
	console.log("File Event",file)
	var reader = new FileReader();
	reader.addEventListener('load', function(e) {
		console.log("value is::"+e.target.result)
		var text = e.target.result;
		localStorage.setItem('IMPORT_FILE',text);
		console.log("file content is",text)
	});
	reader.readAsText(file);
	});

	window.pd=new PD();
}


//TODO: Everthing below is way to hard coded!

</script>

<style>

#functions {position:fixed;top:0;left:0;background:darkgray;bottom:0;width:10vw}

#game {position:fixed;top:0;left:10vw;background:green;bottom:0;width:90vw}

#tray {position:fixed;top:0;left:10vw;background:lightgray;height:7vw;width:90vw;}

#field {position:fixed;top:7vw;bottom:0;background:white;width:90vw;}

#piecearea {user-select: none; }

#operations{display:block}

.gamearea{display:block;float:left;user-select: none;text-align:center;outline:1px solid #eee;color:#ddd}

.boardarea{background:gray;}

.piece {position:fixed;top:0;width:9vw;height:9vw}

.bmAround {pointer-events: none}

</style>

</head>

<body onload="initialize();">


<div id="functions">

<div id="operations">

<button onclick="pd.ui.rotateRight();">Rotate right</button>
<button onclick="pd.ui.rotateLeft();">Rotate left</button>
<button onclick="pd.ui.flipH();">Flip Horizontally</button>
<button onclick="pd.ui.flipV();">Flip Vertically</button> 

<button style="display:none" onclick="pd.ui.save()">Save</button>
<button style="display:none" onclick="pd.ui.load()">Load</button>

<button onclick="pd.ui.export()">Export</button>
<input type="file" id="file-input" />
<button onclick="pd.ui.import()">Import</button>
<button onclick="pd.ui.reset()">Reset</button>

</div>

</div>
<div id="game">

<div id="tray">


</div>

<div id="field">


</div>


</div>

<div id="piecearea">
</div>
</body>
</html>